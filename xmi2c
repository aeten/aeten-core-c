#!/bin/bash

set -e

CURDIR=$(dirname "${0}")
AETEN_CLI_DIR=${CURDIR}/cots/aeten-cli

PROJECT_NAME=$(sed -n 's/^project: //p' .description)
TAG=$(sed -n 's/^tag: //p' .description)
DESCRIPTION=$(sed -n 's/^description: //p' .description)

$(${AETEN_CLI_DIR}/aeten-ads init - -- "${@}" << EOF
#NAME: $(basename ${0})
#TITLE:  ${PROJECT_NAME^^} $(basename ${0}) manual
#VERSION: ${TAG}
#SHORT_DESCRIPTION: Æten core library XMI to C files generation.
#DESCRIPTION: Generates C file (header and a source skeleton) from UML XMI descriplion file.
mode <mode>: The generation mode, _simple_ support only one parent per interface whereas _complete_ support several and provides castable ojects (ie. cast a list to iterable).
!in <file>: The input UML XMI file.
!out <file>: The output file must be formed of *.h for header or *.c for c file skeleton.
version|V: Shows ${PROJECT_NAME} version.
EOF
)

: ${MODE:=complete}
case "$MODE" in
	simple) ;;
	complete) echo 'Complete mode is not yet supported' >&2; exit 1;;
	*)        echo "Invalid mode '${MODE}'" >&2; exit 1;;
esac

XMI="${IN}"
[ -f "$XMI" ] || { echo "Input XMI file '${XMI}' is not a file"; exit 1; }


get_parent() {
	local class=$1
	local id=$(echo ${class}|cut -d : -f 2)
	local parents=$(xmlstarlet sel -B -t -v "//UML:Generalization[@child='${id}']/@parent" "${XMI}";true)
	if [ ${MODE} = 'simple' ]; then
		set -- ${parents}
		[ ${#} -gt 1 ] && echo 'The simple mode support only one parent per interface' >&2 && exit 1
	fi
	for id in ${parents}; do
		class=$(echo ${CLASSES}|awk -F: 'BEGIN{ RS = " " } $2 ~ /'${id}'/ { print $0 }')
		echo $class
		return 0
	done
}

get_parents() {
	local class=$1
	local id=$(echo ${class}|cut -d : -f 2)
	local parents=$(xmlstarlet sel -B -t -v "//UML:Generalization[@child='${id}']/@parent" "${XMI}";true)
	if [ ${MODE} = 'simple' ]; then
		set -- ${parents}
		[ ${#} -gt 1 ] && echo 'The simple mode support only one parent per interface' >&2 && exit 1
	fi
	for id in ${parents}; do
		class=$(echo ${CLASSES}|awk -F: 'BEGIN{ RS = " " } $2 ~ /'${id}'/ { print $0 }')
		echo $class
		get_parents $class
	done
}

CLASSES=$(xmlstarlet el -v "${XMI}" | awk '/Class\[/ {
	match($0, /@name='"'([^']*)'"'/, classname);
	match($0, /@namespace='"'([^']*)'"'/, namespace);
	match($0, /@xmi.id='"'([^']*)'"'/, id);
	match($0, /@isInterface='"'([^']*)'"'/, is_interface);

	if (is_interface[1] == "true") {
		classtype = "interface";
	} else {
		classtype = "class";
	}
	if (classname[1] !~ /\$\$\$/) {print classtype ":" id[1] ":" namespace[1] ":" classname[1];}
}')

CLASS=$(echo "${CLASSES}"|awk -F: '{if ($4 == "'$(basename ${XMI} .xmi)'") {print}}')
[ -z "${CLASS}" ] && { echo Class $(basename ${XMI} .xmi) not found in ${CLASSES}; exit 1; }
OBJECT=$(echo "${CLASSES}"|awk -F: '{if (($3 == "aeten") && ($4 == "Object")) {print}}')
CLASS_TYPE=${CLASS/:*/}
CLASS_ID=${CLASS/${CLASS_TYPE}:/}
CLASS_ID=${CLASS_ID/:*/}
NAMESPACE=${CLASS/${CLASS_TYPE}:${CLASS_ID}:/}
NAMESPACE=${NAMESPACE/:*/}
CLASS_NAME=${CLASS//*:/}
C_CLASS=${NAMESPACE//./_}_${CLASS_NAME}

PARENT=$(get_parent ${CLASS})
PARENT=${PARENT/ */}
PARENT_TYPE=${PARENT/:*/}
PARENT_ID=${PARENT/${PARENT_TYPE}:/}
PARENT_ID=${PARENT_ID/:*/}
PARENT_NAMESPACE=${PARENT/${PARENT_TYPE}:${PARENT_ID}:/}
PARENT_NAMESPACE=${PARENT_NAMESPACE/:*/}
PARENT_NAME=${PARENT//*:/}
C_PARENT=${PARENT_NAMESPACE//./_}_${PARENT_NAME}
if [ ${C_PARENT} = _ ]; then
	C_PARENT=${C_CLASS}
fi

method_visitor_init='
	local _class="${1}"; shift
	local _name="${1}"; shift
	local _type="${1}"; shift
	local _args="${1}"; shift
	local _stereotype="${1}"; shift
	local _function
	local _static_prefix
	local _constructor
	local _default
	local _static
	local _public
	local _override
	local _parent
	local _parent_type
	local _parent_id
	local _parent_namespace
	local _parent_name
	local _args_without_self
	local _tmp_args
	local _arg
	local _parameterized_types=$(get_class_parameter_types ${CLASS_ID})

	_type=${_type/\[\]/*}
	_type=${_type/<*>/}
	_type=$(full_qualified_type ${_type} "${_parameterized_types}")
	if [ "${_name}" = "${CLASS_NAME}" ] && [ "${_stereotype/*constructor*/constructor}" != constructor ]; then
		_stereotype+=" constructor"
	fi
	if [ "${_stereotype/*classifier*/classifier}" = classifier ]; then
		_static=true
	else
		_static=false
	fi
	if [ "${_stereotype/*public*/public}" = public ]; then
		_public=true
	else
		_public=false
	fi
	if [ "${_stereotype/*default*/default}" = default ]; then
		_default=true
	else
		_default=false
	fi
	if [ "${_stereotype/*override*/override}" = override ]; then
		_override=true
	else
		_override=false
	fi
	if [ ${_name} = ${CLASS_NAME} ] || [ "${_stereotype/*constructor*/constructor}" = constructor ]; then
		_constructor=true
	else
		_constructor=false
	fi
	if ${_constructor}; then
		_parent=$(get_parent ${class})
		_parent=${_parent/ */}
		_parent_type=${_parent/:*/}
		_parent_id=${_parent/${_parent_type}:/}
		_parent_id=${_parent_id/:*/}
		_parent_namespace=${_parent/${_parent_type}:${_parent_id}:/}
		_parent_namespace=${_parent_namespace/:*/}
		_parent_name=${_parent//*:/}
		_c_parent=${_parent_namespace//./_}_${_parent_name}
		if [ ${_c_parent} = _ ]; then
		_c_parent=${c_class}
		fi
		_type="${_c_parent}"
		if [ ${_name} = ${CLASS_NAME} ]; then
			_function=new_${C_CLASS}
			_name=
		else
			_name=_${_name}
			_function=new_${C_CLASS}${_name}
		fi
	else
		if ( ! ( ${_static} && ( ! ${_override} ) || [ ${CLASS_TYPE} = interface ] ) ); then
			_static_prefix="static "
		fi
		_function=${_name}
	fi
	_tmp_args="${_args}"
	_args=
	for _arg in $(echo "${_tmp_args}"|awk "BEGIN{RS=\",\"}{match(\$0, /^\s*([^ ]+\s*\*?)\s*([^ ^\n]+)\s*\$/, arg);print arg[2] \":\" arg[1]}"); do
		[ -z "${_args}" ] || { _args+=", "; }
		_arg=${_arg// /}
		_args+="$(full_qualified_type "${_arg/*:/}" ${_parameterized_types}) ${_arg/:*/}"
	done
	_args_without_self=${_args}
	if [ -z "${_args/ /}" ]; then
		_args="${c_class}* self"
	else
		_args="${c_class}* self, ${_args}";
	fi
'

class_visitor_init='
	local class=$1
	local classtype=${class/:*/}
	local classid=${class/${classtype}:/}
	classid=${classid/:*/}
	local namespace=${class/${classtype}:${classid}:/}
	namespace=${namespace/:*/}
	local classname=${class//*:/}
	local c_class=${namespace//./_}_${classname}
'

methods_class_visitor_init='
	local methods=$(xmlstarlet sel -B -t -m "//UML:Class[@xmi.id='"'"'${classid}'"'"']/UML:Classifier.feature/UML:Operation" -v "concat(./@name, '"'"' «'"'"', ./@ownerScope, '"'"'» '"'"', '"'"'«'"'"', @visibility, '"'"'»'"'"')" -n "${XMI}"|sed "s/&lt;/</g;s/&gt;/>/g"; true)
	if [ ${classtype} = class ] && { echo "${methods}"|grep -q -v "${classname}\s*(\s*${c_class}\*" ; }; then
		methods+=$(echo -e "${classname}() «classifier» «public»\n")
	fi
'

get_class_parameter_types() {
	local _classid=${1}
	xmlstarlet sel -B -t -m "//UML:Class[@xmi.id='${_classid}']//UML:Parameter" -v "concat(./@name, ':', ./UML:Parameter.type/UML:DataType/@name, ' ')" ${XMI}
}

attributes_class_visitor_init='
	local attributes=$(xmlstarlet sel -B -t -m "//UML:Class[@xmi.id='"'"'${classid}'"'"']/UML:Classifier.feature/UML:Attribute" -v "concat(./@name, '"'"' «'"'"', ./@ownerScope, '"'"'» '"'"', '"'"'«'"'"', @visibility, '"'"'»'"'"')" -n "${XMI}"|sed "s/&lt;/</g;s/&gt;/>/g"; true)
'

attributes_visitor_init='
	local _attribute=${@}
	_attribute=$(echo "${_attribute}"|tr "\n" " ")
	local _name="${_attribute/:*/}"
	local _type="${_attribute/${_name}:/}"
	_type="${_type/«*/}"
	local _stereotypes="${_attribute/${_name}:${_type}/}"
	_name="${_name// /}"
	_type="${_type// /}"
	_type=$(full_qualified_type "${_type/\[\]/*}" $(get_class_parameter_types ${CLASS_ID}))
	local _stereotypes="${_stereotypes//[«»]/ }"
	local _public
	local _static
	if [ "${_stereotypes/*classifier*/classifier}" = classifier ]; then
		_static=true
	else
		_static=false
	fi
	if [ "${_stereotypes/*public*/public}" = public ]; then
		_public=true
	else
		_public=false
		_name=_${_name}
	fi
	if [ "${_stereotypes/*final*/final}" = final ]; then
		_final=true
	else
		_final=false
	fi
'

full_qualified_type() {
	local _type=${1}; shift
	local _parametrized_types="$@"
	local _parametrized_type
	local _class_to_resolve
	local _pointer
	local _class
	local _classtype
	local _classid
	local _namespace
	local _classname
	if [ -z "${_type}" ]; then
		return
	fi
	_class_to_resolve=$(echo "${_type}"|sed 's/[^a-ZA-Z0-9^_]*\([a-ZA-Z0-9_]\+\)[^a-ZA-Z0-9^_]*/\1/')
	for _parametrized_type in $(echo -e "${_parametrized_types// /\\n}"); do
		if [ ${_class_to_resolve} = ${_parametrized_type/:*/} ]; then
			_class_to_resolve=${_parametrized_type/*:/}
			_class_to_resolve=${_class_to_resolve// /}
		break
		fi
	done
	for _class in ${CLASSES}; do
		_classtype=${_class/:*/}
		_classid=${_class/${_classtype}:/}
		_classid=${_classid/:*/}
		_namespace=${_class/${_classtype}:${_classid}:/}
		_namespace=${_namespace/:*/}
		_classname=${_class//*:/}
		if [ ${_classname} = ${_class_to_resolve} ]; then
			echo $(echo "${_type}"|sed 's/\([^a-ZA-Z0-9^_]*\)\([a-ZA-Z0-9_]\+\)\([^a-ZA-Z0-9^_]*\)/\1'${_namespace//./_}_${_classname}'\3/')
			return 0
		fi
	done
	echo $(echo "${_type}"|sed 's/\([^a-ZA-Z0-9^_]*\)\([a-ZA-Z0-9_]\+\)\([^a-ZA-Z0-9^_]*\)/\1'${_class_to_resolve}'\3/')
}


visit_class() {
	local _visitor="${1}_class_visitor"; shift
	local _class="$1"; shift
	eval ${_visitor} "${_class}"
}

visit_attribute() {
	local _visitor="${1}_attribute_visitor"; shift
	local _class="$1"; shift
	local _attribute="${1}"
	eval "${_visitor} '${_class}' '${_attribute}'"
}

visit_method() {
	local _visitor="${1}_method_visitor"; shift
	local _class="$1"; shift
	local _method=$(echo "$1"|sed 's/&lt;/</g;s/&gt;/>/g')
	eval ${_visitor} "${_class}" $(echo "${_method}" | gawk '{
		match($0, /(([^ ]+) +)?([^ (]+) *\( *([^)]*)? *\) *(«.*)?/, signature);
		if (signature[2] == "") {
			type = "void";
		} else {
			type = signature[2];
		}
		name = signature[3];
		args = signature[4];
		stereotype = signature[5];
		gsub(/[«»]/,"",stereotype);
		print "'"'"'" name "'"' '"'" type "'"' '"'" args "'"' '"'" stereotype "'"'"'";
	}')
}

typedef_method_visitor() {
	eval "${method_visitor_init}"
	[ "${_stereotype}" = "constructor" ] && return
	( ! ${_override} ) && ( ! ${_static} ) && {
			echo "typedef ${_type} (*${C_CLASS}_${_name}_t)($(echo "${_args}"|sed "s/^${c_class}\\* _\?self/${C_CLASS}* self/"));"
	}
}

object_declaration_attribute_visitor() {
	eval "${attributes_visitor_init}"
	${_static} || {
		if ${_final}; then
			if [ "${_type/*\**/*}" = '*' ] || [ "${_type/*\[\]*/[]}" = '[]' ]; then
				echo -e "\t${_type} const ${_name};"
			else
				echo -e "\tconst ${_type} ${_name};"
			fi
		else
			echo -e "\t${_type} ${_name};"
		fi
	}
}

static_declaration_attribute_visitor() {
	eval "${attributes_visitor_init}"
	if ${_static}; then
		if ${_final}; then
			if [ "${_type/*\**/*}" = '*' ] || [ "${_type/*\[\]*/[]}" = '[]' ]; then
				echo "static ${_type} const ${_name};"
			else
				echo "static const ${_type} ${_name};"
			fi
		else
			echo "static ${_type} ${_name};"
		fi
	fi
}

callback_method_visitor() {
	eval "${method_visitor_init}"
	[ "${_stereotype}" = "constructor" ] && return
	( ! ${_override} ) && ( ! ${_static} ) && echo -e "\t${C_CLASS}_${_name}_t ${_name};"
}

declaration_method_visitor() {
	eval "${method_visitor_init}"
	local _cls
	local _args
	${_override} && return 0
	if ${_constructor}; then
		cat - <<EOF
${_type}  ${_function/${CLASS_NAME}/${CLASS_NAME}_fromStack}(${_args_without_self});
${_type} *${_function}(${_args_without_self});
EOF
	elif ${_public}; then
		if ${_static}; then
			echo "${_type} ${C_CLASS}_${_function}(${_args_without_self});"
		else
			echo "${_type} ${C_CLASS}_${_function}(${_args/${c_class}\* self/${C_CLASS}* self});"
		fi
	fi
}

definition_method_visitor() {
	eval "${method_visitor_init}"
	local _cls

	_args=$(echo "${_args}"|sed "s/^${c_class}\\* self/${C_CLASS}* self/")
	${_constructor} && _name=new${_name}
	
	cat - <<EOF

${_type} _${_name}(${_args}) {
	// TODO: Implement
}
EOF
}

import_method_visitor() {
	eval "${method_visitor_init}"
	local _cls
	if ${_constructor}; then
		cat - <<EOF
#	define ${_function/_${NAMESPACE//./_}/}           ${_function}
#	define ${_function/_${NAMESPACE//./_}/}_fromStack ${_function}_fromStack
EOF
	fi
}

helper_method_visitor() {
	eval "${method_visitor_init}"
	local _cls

	if  ( ! ${_constructor} ); then
		if ( [ ${CLASS_TYPE} = class ] && ( [ ${classtype} = interface ] && ( ! ${_default} ) ) || ( ${_override} && [ ${c_class} = ${C_CLASS} ] ) ) || ( [ ${c_class} = ${C_CLASS} ] && ${_default} ); then
			echo "static ${_type} ${CLASS_NAME}_${_name}(${_args/${c_class}\* self/${C_CLASS}* self});"
		fi
		if ( ! ${_override} ); then
			if ${_static}; then
				cat - <<EOF
static inline ${_type} ${CLASS_NAME}_${_name}(${_args_without_self});
${_type} ${C_CLASS}_${_function}(${_args_without_self}) {
	return ${CLASS_NAME}_${_name}($(echo "${_args_without_self}"|awk -F' ' 'BEGIN{RS=",";ORS=","}{print $2}'|sed 's/,$//'));
}

EOF
			else
				cat - <<EOF
${_type} ${C_CLASS}_${_function}(${_args/${c_class}\* self/${C_CLASS}* self}) {
	check(self != NULL, NullPointerException, "self");
	return self->_self->${_function}($(echo "${_args/self/self->_self}"|awk -F' ' 'BEGIN{RS=",";ORS=","}{print $2}'|sed 's/,$//'));
}

EOF
			fi
		fi
	else
		cat - <<EOF
inline static void ${CLASS_NAME}_new${_name}(${_args/${c_class}\* self/${C_CLASS}* self});
${C_PARENT}* ${_function}(${_args_without_self}) {
	${C_CLASS}* self = malloc(sizeof(${C_CLASS}));
	check(self != NULL, HeapAllocationException, "self = malloc(%lu)", sizeof(${C_CLASS}));
	_${C_CLASS}_init(self);
	${CLASS_NAME}_new${_name}($(echo "${_args}"|awk -F' ' 'BEGIN{RS=",";ORS=","}{print $2}'|sed 's/,$//'));
	return (${C_PARENT}*)self;
}
inline ${C_PARENT} ${_function/${CLASS_NAME}/${CLASS_NAME}_fromStack}(${_args_without_self}) {
	${C_CLASS}* self = alloca(sizeof(${C_CLASS}));
	check(self != NULL, StackAllocationException, "self = alloca(%lu)", sizeof(${C_CLASS}));
	_${C_CLASS}_init(self);
	self->delete = self->finalize;
	${CLASS_NAME}_new${_name}($(echo "${_args}"|awk -F' ' 'BEGIN{RS=",";ORS=","}{print $2}'|sed 's/,$//'));
	return *((${C_PARENT}*)self);
}

${C_PARENT}_Array* ${_function/new_/newArrayOf_}(${_args/${c_class}* self/size_t _length}) {
	${C_CLASS}_Array* array = malloc(sizeof(${C_PARENT}_Array) + (_length * (sizeof(${C_CLASS}*)+sizeof(${C_CLASS}))));
	check(array != NULL, HeapAllocationException, "array = malloc(%lu+%lu*%lu)", sizeof(${C_CLASS}_Array), _length, sizeof(${C_CLASS}));
	array->length = _length;
	array->size = sizeof(${C_CLASS});
	for (size_t i=0; i<_length; ++i) {
		_${C_CLASS}_init(&array->values[i]);
		${CLASS_NAME}_new${_name}($(echo "${_args/self/&array->values[i]}"|awk -F' ' 'BEGIN{RS=",";ORS=","}{print $2}'|sed 's/,$//'));
	}
	return (${C_PARENT}_Array*)array;
}

EOF
	fi
}

interface_init_method_visitor() {
	eval "${method_visitor_init}"
	if ( ! ${_constructor} ) && ${_default} && [ ${c_class} = ${C_CLASS} ] && [ ${CLASS_TYPE} = interface ]; then
		echo -e "\tself->${_name} = ${CLASS_NAME}_${_name};"
	fi
}

constructor_definition_method_visitor() {
	eval "${method_visitor_init}"
	if ( ! ${_constructor} ) ; then
		echo -n ${_name}
		${_override} && [ ${c_class} = ${C_CLASS} ] && echo -n :override
		${_default} && echo -n :default
		echo 
	fi
}

include_class_visitor() {
	eval "${class_visitor_init}"
	echo '#include "'${namespace//./\/}/${classname}.h'"'
}

definition_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	IFS=$'\n'
	for method in ${methods}; do
		visit_method definition "${c_class}" "${method}"
	done
	unset IFS
}

typedef_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	IFS=$'\n'
	for method in ${methods}; do
		visit_method typedef "${c_class}" "${method}"
	done
	unset IFS
}

methods_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	local _method

	if [ -n "${methods}" ]; then
		echo "// Methods of ${c_class}"
		IFS=$'\n'
		for _method in ${methods}; do
			visit_method callback "${c_class}" "${_method}"
		done
		unset IFS
	fi
}

helper_methods_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	local _method

	if [ -n "${methods}" ]; then
		echo -e "// Methods of ${c_class}"
		IFS=$'\n'
		for _method in ${methods}; do
			visit_method helper "${c_class}" "${_method}"
		done
		unset IFS
	fi
}

import_methods_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	local _method

	if [ -n "${methods}" ]; then
		IFS=$'\n'
		for _method in ${methods}; do
			visit_method import "${c_class}" "${_method}"
		done
		unset IFS
	fi
}

attributes_instance_class_visitor() {
	eval "${class_visitor_init}"
	eval "${attributes_class_visitor_init}"
	local _attribute

	if [ -n "${attributes}" ]; then
		echo -e "// Attributes of ${c_class}"
		IFS=$'\n'
		for _attribute in ${attributes}; do
			visit_attribute object_declaration "${_attribute}"
		done
		unset IFS
	fi
}

attributes_static_class_visitor() {
	eval "${class_visitor_init}"
	eval "${attributes_class_visitor_init}"
	local _attribute

	if [ -n "${attributes}" ]; then
		echo -e "// Attributes of ${c_class}"
		IFS=$'\n'
		for _attribute in ${attributes}; do
			visit_attribute static_declaration "${_attribute}"
		done
		unset IFS
	fi
}

method_declaration_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	local _method

	if [ -n "${methods}" ]; then
		IFS=$'\n'
		for method in ${methods}; do
			visit_method declaration "${c_class}" "${method}"
		done
		unset IFS
	fi
}

method_definition_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	local method

	if [ -n "${methods}" ]; then
		IFS=$'\n'
		for method in ${methods}; do
			visit_method definition "${c_class}" "${method}"
		done
		unset IFS
	fi
}

constructor_init_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"

	if [ ${c_class} != ${C_CLASS} ] && [ ${CLASS_TYPE} = class ]; then
		echo -e "\t_${c_class}_init((${c_class}*)self);"
	else
		IFS=$'\n'
		for method in ${methods}; do
			visit_method interface_init "${c_class}" "${method}"
		done
		unset IFS
	fi
}

constructor_definition_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	local method

	IFS=$'\n'
	for method in ${methods}; do
		visit_method constructor_definition "${c_class}" "${method}"
	done
	unset IFS
}

header_class_visitor() {
	eval "${class_visitor_init}"
	local cls

	cat - <<EOF
#ifndef ${c_class^^}_H
#define ${c_class^^}_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#include "aeten/lang.h"

EOF
	for cls in ${CLASSES}; do
		if [ "${cls}" != "${CLASS}" ]; then
			visit_class include ${cls}
		fi
	done
	cat - <<EOF

typedef struct _${c_class} ${c_class};
typedef struct {
	size_t length;
	size_t size;
	${c_class} *values;
} ${c_class}_Array;

void _${C_CLASS}_init(${c_class}* self);

EOF
	for cls in ${CLASS_HIERARCHY}; do
		visit_class typedef ${cls}
	done
	echo
		echo "struct _${c_class} {"
		echo -e "\tuint32_t const _mark;"
		echo -e "\t${c_class}* const _self;"
		for cls in ${CLASS_HIERARCHY}; do
			visit_class methods ${cls}
			visit_class attributes_instance ${cls}
		done
		echo -e '};\n'

	for cls in ${CLASS_HIERARCHY}; do
		visit_class method_declaration ${cls}
	done

	cat - <<EOF

#ifdef _${C_CLASS^^}_PRIVATE
$(visit_class c_private ${CLASS})
#endif // _${C_CLASS^^}_PRIVATE

#endif // ${c_class^^}_H

#if defined(import) || defined(_${C_CLASS^^}_PRIVATE)
#	define ${CLASS_NAME} ${C_CLASS}
#	define ${CLASS_NAME}_Array ${C_CLASS}_Array
#endif
EOF
	if [ ${classtype} = class ]; then
		echo "#if defined(import) || defined(_${C_CLASS^^}_PRIVATE)"
	else
		echo "#if defined(import)"
	fi
	_methods=$(for _cls in ${CLASS_HIERARCHY}; do
		visit_class constructor_definition ${_cls}
	done)

	for _method_name in ${_methods}; do
		[ ${_method_name/:default/} != ${_method_name} ] && _default_methods+=$(echo "${_method_name/:*/}\n")
		[ ${_method_name/:override/} != ${_method_name} ] && _override_methods+=$(echo "${_method_name/:*/}\n")
	done
	_methods=${_methods//:default/}
	_methods=${_methods//:override/}
	_methods=$(echo -e "${_methods}"|sort -u)
	if [ ${classtype} = class ]; then
		echo "#	ifndef _${C_CLASS^^}_PRIVATE"
	fi
	for _method_name in $({ echo -e "${_override_methods}"; comm -13 --nocheck-order <(echo -e "${_default_methods}"|sort -u) <(echo -e "${_methods}"|sort -u); }|sort -u); do
		echo "#		define ${CLASS_NAME}_${_method_name} ${C_CLASS}_${_method_name}"
	done
	if [ ${classtype} = class ]; then
		echo "#	endif"
	fi
	for _method_name in $({ comm -13 --nocheck-order <(echo -e "${_override_methods}"|sort -u) <(echo -e "${_default_methods}"|sort -u); }|sort -u); do
		echo "#	define ${CLASS_NAME}_${_method_name} ${C_CLASS}_${_method_name}"
	done

	cat - <<EOF
$(for _cls in ${CLASS_HIERARCHY}; do
	visit_class import_methods ${_cls}
done)
#endif
EOF
}

c_private_class_visitor() {
	eval "${class_visitor_init}"
	eval "${methods_class_visitor_init}"
	local _cls
	local _methods
	local _method_name
	local _default_methods
	local _override_methods

	cat - <<EOF
#include <assert.h>
#include <string.h>

$(for _cls in ${CLASS_HIERARCHY}; do
	visit_class attributes_static ${_cls}
	visit_class helper_methods ${_cls}
done)

void _${C_CLASS}_init(${c_class}* self) {
EOF
	if [ ${classtype} = class ]; then
		cat - <<EOF
	check(self != NULL, NullPointerException, "Cannot int instance of ${C_CLASS}");
	uint32_t mark = _AETEN_MARK;
	char *ptr = (char*)self;
	memcpy(ptr + offsetof(${C_CLASS}, _mark), &mark, sizeof(self->_mark));
	memcpy(ptr + offsetof(${C_CLASS}, _self), &self, sizeof(self->_self));
EOF
	fi

	for _cls in ${CLASS_HIERARCHY}; do
		visit_class constructor_init ${_cls}
	done

	if [ ${classtype} = class ]; then
		_methods=$(for _cls in ${CLASS_HIERARCHY}; do
			visit_class constructor_definition ${_cls}
		done)

		for _method_name in ${_methods}; do
			[ ${_method_name/:default/} != ${_method_name} ] && _default_methods+=$(echo "${_method_name/:*/}\n")
			[ ${_method_name/:override/} != ${_method_name} ] && _override_methods+=$(echo "${_method_name/:*/}\n")
		done
		_methods=${_methods//:default/}
		_methods=${_methods//:override/}
		for _method_name in $({ echo -e "${_override_methods}"; comm -13 --nocheck-order <(echo -e "${_default_methods}"|sort -u) <(echo -e "${_methods}"|sort -u); }|sort -u); do
			echo -e "\tself->${_method_name} = ${CLASS_NAME}_${_method_name};"
		done
	fi
	cat - <<EOF
}

EOF

}

c_source_class_visitor() {
	eval "${class_visitor_init}"
	local cls

	if [ ${classtype} = class ]; then

		cat - <<EOF
/*
@startuml ${CLASS_NAME}
!include Object.c
namespace ${NAMESPACE} {
	class ${CLASS_NAME} implements ${PARENT_NAMESPACE}.${PARENT_NAME} {
	}
}
@enduml
*/

$(for _cls in ${CLASS_HIERARCHY}; do
	visit_class definition ${_cls}
done)

EOF

	fi
}

CLASS_HIERARCHY=$(echo -e "${OBJECT}\n$(get_parents ${CLASS}|tac)\n${CLASS}"|sed '/^$/d'|uniq)
for cls in ${CLASSES}; do
	if [ "${cls}" = "${CLASS}" ]; then
		for output in ${OUT}; do
			case "${output}" in
				*.c) out=c_source;;
				*.h) out=header;;
				*)   echo "Invalid output file extension for '${output}'" >&2; exit 1;;
			esac
			visit_class ${out} ${cls} > "${output}" || {
				rm -f "${output}"
				exit 1
			}
		done
	fi
done

